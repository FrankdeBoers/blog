```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
```

一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用递归来处理。

* [递归](#递归)
    * [1. 树的高度](#1-树的高度)
    * [2. 平衡树](#2-平衡树)
    
## 1. 树的高度    
[104. Maximum Depth of Binary Tree (Easy)](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/)

### 思路：
利用递归，递归出口是root==null，最终返回左、右子树的最大值+1；

### 代码：
```java
public int maxDepth(TreeNode root) {
	if (root == null) {
		return 0;
	}

	int l = maxDepth(root.left);
	int r = maxDepth(root.right);
	return Math.max(l, r) + 1;        
}
```
![树的高度](https://raw.githubusercontent.com/FrankdeBoers/blog/master/static/img/treeDepth.png)

### 2. 平衡树

[110. Balanced Binary Tree (Easy)](https://leetcode.com/problems/balanced-binary-tree/description/)

Given the following tree [3,9,20,null,null,15,7]:

```html
    3
   / \
  9  20
    /  \
   15   7
```

### 思路：
利用求解树的高度的方法，在求高度的同时，判断左右字数的高度是否大于1。

### 代码：
```java
boolean isBalance = true;
public boolean isBalanced(TreeNode root) {
	getDepth(root);
	return isBalancel;
}

private int getDepth(TreeNode root) {
	if (root == null) {
		return 0;
	}

	int l = getDepth(root.left);
	int r = getDepth(root.right);
  // 大于1，则标志位置为false
	if (Match.abs(l-r) > 1) {
		isBalance = false;
	}

	return Math.max(l, r) + 1;
}
```









